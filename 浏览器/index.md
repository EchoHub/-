### 浏览器进程、线程
- 进程代表cpu分配内存的最小单元，线程代表cpu调度的最小单元
- 浏览器是多进程，包含主进程、GPU进程、渲染进程、插件进程等
- 与前端相关的主要为渲染进程，每个页面都会有一个渲染进程
- 渲染进程里面包含多个线程，如GUI渲染线程、js引擎线程、事件触发线程、定时器线程、http线程等
- GUI渲染线程与js引擎线程为互斥单元，因此js的执行会阻塞渲染

### 为什么js是单线程的
- 举个例子，若js为多线程模式，在A线程中js将domA删除，而在B线程中操作domA就会报错，因此js如果为多线程会导致很多不可预期的场景，因此js为单线程模式

### 为什么渲染线程与js线程互斥
- 因为js可以操作dom，如果两线程不互斥，则会导致两线程同时执行产生的预期不一致

### 浏览器渲染流程
- 解析html文档，并生成DOM树，DOM由DOM元素以及属性节点组成。
- 解析css，生成CSSOM规则树
- 根据DOM树和CSSOM规则树构建渲染树，渲染树由渲染对象组成，渲染对象包含一个个元素的DOM信息以及CSS属性信息
- 浏览器根据渲染树进行文档的布局
- 布局结束后浏览器会遍历渲染树，并调用渲染对象中的paint方法进行元素的绘制

### EventLoop
- 浏览器事件循环
    - js分为同步任务和异步任务，同步任务会在js引擎线程里面执行，而对于异步任务例如定时任务、网络请求等，会交给对应的线程处理，在事件触发线程里面有一个任务队列，异步任务处理完成之后会把回调函数放入任务队列里面，当js引擎线程空闲下来时，系统会将任务队列里面的任务放入执行栈内执行，以此循环。
    - 异步任务分为宏任务、微任务，每次执行栈执行就是一次宏任务，浏览器为实现宏任务与DOM任务有序进行，会在当前宏任务完成，下一次宏任务开始之前，执行渲染，即渲染线程进行工作
    - 微任务可以理解为当前宏任务执行完成之后立即执行的任务叫做微任务
    - 分类
        - 常见的宏任务：script、定时器、requestAnimationFrame、GUI渲染、I/O操作
        - 常见的微任务：promise、async/await、MutationObserver
- Node事件循环
    Node环境js的解析、执行交由V8引擎，其事件循环不同于浏览器：
    - 定时任务
    - I/O操作 处理上一个循环未处理掉的I/O
    - idle即空闲时段任务
    - poll循环任务 获取新的I/O
    - check 执行setImmediate回调
    - close callbacks socket的close关掉

### 浏览器缓存策略
浏览器缓存分为强制缓存、协商缓存两种，强制缓存的优先级大于协商缓存：强制缓存即服务器告诉客户端资源缓存时间，在这个时间有效期内直接使用本地缓存；协商缓存即客户端向服务端发起资源请求，服务端根据请求携带的Etag、Last-Modified等协商字段验证资源是否有更新，若更新返回新的资源，若未更新则返回304，告知客户端直接使用浏览器缓存。
- 强制缓存标识：Cache-Control、Expires
    - Cache-Control表示一个相对时间，即上一次正确请求完成之后多少秒内使用缓存
    - Expires表示一个绝对时间，即这个时间之前使用缓存，之后不使用缓存
    - Cache-Control优先级要高于Expires
    - 强制缓存直接返回200
- 协商缓存标识：Etag、Last-Modified
    - Etag/If-None-Match 资源的唯一标识，当资源发生更新，则重新生成新的标识
    - Last-Modified/If-Modified-Since 表示资源最后一次更新的时间、
    - Etag的优先级大于Last-Modified
    - 若命中缓存则只返回304状态，若未命中则返回新的资源，状态返回200

### 浏览器缓存机制全流程
- 浏览器第一次加载资源，会对资源进行缓存，且存储资源的头部信息；
- 当浏览器进行第二次资源请求是，会根据强缓存策略， 校验当前时间与上一次资源返回时间的值是否超过资源文件中的Cache-Control字段中的max-age，若过期则发起资源请求，若为http1.0协议则校验expires字段判断资源是否过期，若过期则发起资源请求
- 请求会携带If-None-Match/If-Modfied-Since头信息请求服务器，服务器根据etag值判断资源是否发生更新，若没有则返回302状态，告诉客户端使用本地缓存；若etag发生变化则返回200，且返回新的资源内容和etag
- 若服务端接收请求中没有etag，则将If-Modified-Since中的值与被请求资源最后更新的时间对比，若一致则返回302，告诉客户端使用缓存，若不一致则返回200，且返回新的资源内容和last-modified

### 为什么需要浏览器缓存
- 减少服务器请求带来的带宽压力
- 提升页面加载速度
- 减少冗余的请求，譬如一些低频更新的静态资源等

### 本地缓存的方式有哪些
- cookie
- sessionStorage
- localStorage
- Web SQL
- IndexexDB

